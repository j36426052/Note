<!DOCTYPE html>
<html class="writer-html5" lang="zh-TW" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chapter 3. Transport Layer &mdash; QSnake Markdown Note v1 說明文件</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/translations.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜尋" href="../../search.html" />
    <link rel="next" title="Chapter 4 The Network Layer: Data Plane" href="4.html" />
    <link rel="prev" title="Chapter 2. Application Layer" href="2.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> QSnake Markdown Note
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../Dev/index.html">Dev Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Linux/index.html">Linux Page</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../docs/index.html">Docs Page</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">Course Page</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="index.html">Internet Page</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="hw/index.html">Internet HW Page</a></li>
<li class="toctree-l3"><a class="reference internal" href="1.html">Chpater 1 Computer Networks and the Internet</a></li>
<li class="toctree-l3"><a class="reference internal" href="2.html">Chapter 2. Application Layer</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Chapter 3. Transport Layer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction-and-transport-layer-services">3.1 Introduction and Transport-Layer Services</a></li>
<li class="toctree-l4"><a class="reference internal" href="#multiplexing-and-demutiplexing">3.2 Multiplexing and Demutiplexing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connectionless-transport-udp">3.3 Connectionless Transport: UDP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#principles-of-reliable-data-transfer">3.4 Principles of Reliable Data Transfer</a></li>
<li class="toctree-l4"><a class="reference internal" href="#connection-oriented-transport-tcp">3.5 Connection-Oriented Transport: TCP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#principles-of-congestion-control-control">3.6 Principles of Congestion Control Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#tcp-congestion-control">3.7 TCP Congestion Control</a></li>
<li class="toctree-l4"><a class="reference internal" href="#evolution-of-transport-layer-functionality">3.8 Evolution of Transport-Layer Functionality</a></li>
<li class="toctree-l4"><a class="reference internal" href="#summary">3.9 Summary</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="4.html">Chapter 4 The Network Layer: Data Plane</a></li>
<li class="toctree-l3"><a class="reference internal" href="5.html">Chapter 5 The Network Layer: Control Plane</a></li>
<li class="toctree-l3"><a class="reference internal" href="6.html">Chapter 6 The Link Layer and LANs</a></li>
<li class="toctree-l3"><a class="reference internal" href="7.html">Chapter 7 Wireless and Mobile Networks</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../Beauty/index.html">Tool Page</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QSnake Markdown Note</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Course Page</a></li>
          <li class="breadcrumb-item"><a href="index.html">Internet Page</a></li>
      <li class="breadcrumb-item active">Chapter 3. Transport Layer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/Course/Internet/3.md.txt" rel="nofollow"> 查看页面源码</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="chapter-3-transport-layer">
<h1>Chapter 3. Transport Layer<a class="headerlink" href="#chapter-3-transport-layer" title="本標頭的永久連結"></a></h1>
<section id="introduction-and-transport-layer-services">
<h2>3.1 Introduction and Transport-Layer Services<a class="headerlink" href="#introduction-and-transport-layer-services" title="本標頭的永久連結"></a></h2>
<p>Transport layer 是處理有關processes之間的溝通。在sender端，當上面的network layer 傳下來message之後，會建立segement，並且加上header後給IP，在receiver端，它會確認header的狀態，並且依照情況選擇要不要傳給application layer，詳細的機制後面會提到。而在transport layer最主要會談的就是TCP和UDP:</p>
<p>TCP(Transmission Control Protocol) 是 Reliable 的
UDP(User Datagram Protocol) 什麼鬼都沒有</p>
</section>
<section id="multiplexing-and-demutiplexing">
<h2>3.2 Multiplexing and Demutiplexing<a class="headerlink" href="#multiplexing-and-demutiplexing" title="本標頭的永久連結"></a></h2>
<p>以下是來自<strong>維基百科</strong>的定義</p>
<blockquote>
<div><p>多路複用（Multiplexing，又稱「多工」）是一個通訊和電腦網路領域的專業術語，在沒有歧義的情況下，「多路複用」也可被稱為「複用」。多路複用通常表示在一個頻道上傳輸多路訊號或資料流的過程和技術。</p>
</div></blockquote>
<p>白話一點，由於網路是一個線路（物理上）在溝通，但一次正在傳送資料的可能有許多的電腦，每台電腦裡面又有不同的程序，因此該如何讓這麼多的程序互相溝通，這就是這章需要來討論的。另外，在sender端我們稱為multiplexing，在receiver端稱為demultiplexing。</p>
<p>實際上怎麼運作？上文提到我們主要要把不同的電腦以及程序的資料分開，所以很直覺的，我們會在意port還有ip(ip 給network layer 負責)，而port被放在segement的header前面，並且分為Source和dest(port)，各自16bit，合起來吃了32bit的大小。</p>
<p><img alt="圖片" src="../../_images/3_2-1.png" /></p>
<p><strong>Connectionless Demultiplexing(UDP 的情況)</strong></p>
<blockquote>
<div><ol class="simple">
<li><p>當建立一個socket的時候，一定要指定一個port number(自己的)</p></li>
<li><p>建立datagram的時候，要有目標的ip address和port</p></li>
<li><p>確認segement的destination port number</p></li>
<li><p>只要有同一個dest port和dest ip,就會給同一個socket吃到</p></li>
</ol>
</div></blockquote>
<p><img alt="圖片" src="../../_images/3_2-2.png" /></p>
<p><strong>Connection-oriented demultiplexing(TCP 的情況)</strong></p>
<blockquote>
<div><p>sourceID,sourcePort,destIP,destPort 一個不一樣就會有新的socket</p>
</div></blockquote>
<p><img alt="圖片" src="../../_images/3_2-3.png" /></p>
<p>然而以前這樣開很多Socket會耗很多資源，新的方法是用thread</p>
<p><img alt="圖片" src="../../_images/3_2-4.png" /></p>
</section>
<section id="connectionless-transport-udp">
<h2>3.3 Connectionless Transport: UDP<a class="headerlink" href="#connectionless-transport-udp" title="本標頭的永久連結"></a></h2>
<p>基本上很簡單，因為只要管理自己的東西就好</p>
<p><strong>UDP的特點</strong></p>
<ol class="simple">
<li><p>OS不需要先建立連結，省一個RTT</p></li>
<li><p>不用維持statue</p></li>
<li><p>header size小</p></li>
</ol>
<p><strong>UDP Segment Structure</strong>
就header，header裡面有這些</p>
<ol class="simple">
<li><p>source port number</p></li>
<li><p>dest port number</p></li>
<li><p>length：整個segment的長度(包含header(至少8))</p></li>
<li><p>checksum</p></li>
</ol>
<p><strong>UDP Checksum</strong></p>
<p>知道整個封包有沒有錯的機制（注意：沒有要復原的意思，就知道錯而已）：把整個segement以16bit為單位切成一格，把大家都加起來變成一個sum(一個二進位的值)checksum的算法就是把sum的01翻過來，如果reciver發現有錯，那就會把封包丟掉，沒有錯就會接收。</p>
<p><img alt="../../_images/3_3-1.png" src="../../_images/3_3-1.png" /></p>
</section>
<section id="principles-of-reliable-data-transfer">
<h2>3.4 Principles of Reliable Data Transfer<a class="headerlink" href="#principles-of-reliable-data-transfer" title="本標頭的永久連結"></a></h2>
<p>因為網路是個不穩定的環境，所以要盡量控制那個錯誤，那就是reliable data transfer protocol</p>
<p><img alt="Interface" src="../../_images/3_4-1.png" /></p>
<p>要注意圖片裡面的called from above和called from below</p>
<section id="finite-state-machine-fsm">
<h3>Finite state machine(FSM)<a class="headerlink" href="#finite-state-machine-fsm" title="本標頭的永久連結"></a></h3>
<p><img alt="Interface" src="../../_images/3_4-2.png" /></p>
<p>假如一個系統很龐大，你不能直接用直覺判斷每個程序執行到什麼階段，因此用狀態來判別整個系統執行到那裡</p>
<p>舉例：販賣機</p>
<blockquote>
<div><p>在販賣機裡面，我們可以簡單劃分幾個階段</p>
<ol class="simple">
<li><p>接收硬幣</p></li>
<li><p>把商品燈亮起來，等待使用者去按
假設我們想要把販賣機化成流程圖討論，那當你有許多的商品時，你就需要多畫一條非常類似的線去討論該執行哪些事情，並且討論突發狀況時會有些複雜，而使用Finite state machine，我們就可以單就現在機器等待的狀態去討論。</p></li>
</ol>
</div></blockquote>
<p>而每個狀態到每個狀態之間要分別標示event和action，而event是觸發action的條件（例如在販賣機裡面，假如硬幣端收到了「接收夠多的前」這個event，那就會執行把燈亮起來的東做，並且等待使用者去按）而在規劃FSM的時候，可以畫表格來確定系統裡面會有哪些event，再畫成上面圖片的樣子。</p>
<blockquote>
<div><p>在畫表格的時候，假如看到state之間沒有event，還是可以思考一下系統會不會出現一些bug，可以多一點catch throw 的空間</p>
</div></blockquote>
</section>
<section id="building-a-reliable-data-transfer-protocol">
<h3>Building a Reliable Data Transfer Protocol<a class="headerlink" href="#building-a-reliable-data-transfer-protocol" title="本標頭的永久連結"></a></h3>
<p><strong>RDT 1.0</strong></p>
<p>假設：no bit error,no loss of packets
| sender的FSM | receiver的FSM |
|—|—|
|<img alt="picture" src="../../_images/3_4-3.png" />|<img alt="picture" src="../../_images/3_4-4.png" />|
|等call from above, 之後就把封包裝一裝，就丟出去，再等第二個封包|等 call from below, 接著拆封包|</p>
<p><strong>RDT 2.0</strong></p>
<p>假設：channel with bit errors
特色：reciever 要通知sender說他送錯了，請再送一次</p>
<ul class="simple">
<li><p>acknowledgements(ACKs): reciver告訴sender傳好的</p></li>
<li><p>negative acknowledgements(NAKs): receiver 告訴sender傳的有error</p></li>
</ul>
<ol class="simple">
<li><p>sender的FSM <br> <img alt="picture" src="../../_images/3_4-5.png" /> <br> Sender 一樣在call from above的狀態，收到訊息之後，要先算出checksum讓sender可以偵測error，接著把封包丟過去，接著進到wait for ack 的狀態，假如收到成功就結束了，等待下一個call from above. 假如失敗了，那就再送一次，然後再回到wait for ack.</p></li>
<li><p>receiver的FSM <br> <img alt="picture" src="../../_images/3_4-6.png" /><br> receiver一直在wait for call from below，接到東西之後開始確定有沒有問題，假如沒問題就多送一個ack過去，失敗的話就回傳，回傳過後一樣回到wait for call from below</p></li>
</ol>
<blockquote>
<div><p>有互相等待的機制就叫 stop and wait</p>
</div></blockquote>
<p><em>萬無一失？</em>
假如送回去的ack或nak資料遺失怎麼辦（那個channel是不穩定地，會有bit error），上面沒有明確規範，所以需要RDT 2.1</p>
<p><strong>RDT 2.1</strong>
為了避免sender因為判斷不出來ack nak在說什麼，因此幫封包來個編號，比免送過去重複的資料。</p>
<p><img alt="picture" src="../../_images/3_4-7.png" /></p>
<p>可以注意到在右上角的箭頭（wait for ack or nak 自己傳回去），它的條件多了一個corrupt(rcvpkt)，基本上ack壞掉一樣會再傳一次。</p>
<p><img alt="picture" src="../../_images/3_4-8.png" /></p>
<p>重點：所有的封包都帶有checksum還有packet number，假如ack機制壞掉，receiver可以跟sender提醒他剛剛的東西收過了或者是沒收到</p>
<p><strong>RDT 2.2</strong></p>
<p>特色：不使用NAK
那要用什麼呢？ACK加上『下一個』想要收到的資料的編號。</p>
<p><img alt="picture" src="../../_images/3_4-9.png" /></p>
<p><strong>RDT 3.0</strong></p>
<p>問題：加上了loss
現實情況：基本上只有sender知道有沒有到，因此請sender加上timer自行評估。</p>
<p><img alt="picture" src="../../_images/3_4-10.png" /></p>
<p>假設sender的timer已經到了，但其實ack有回來(duplicate ack)，但這樣D1還是會再送一次，因此ack的編號很重要，不然會搞錯。</p>
<p><em>Performance</em>
<img alt="../../_images/3_4-11.png" src="../../_images/3_4-11.png" /></p>
<p><img alt="../../_images/3_4-12.png" src="../../_images/3_4-12.png" />
效率極差，因為是stop-and-wait，需要等到Receiver回傳的時候才會傳東西回來。</p>
</section>
<section id="pipelined-reliable-data-transfer-protocols">
<h3>Pipelined Reliable Data Transfer Protocols<a class="headerlink" href="#pipelined-reliable-data-transfer-protocols" title="本標頭的永久連結"></a></h3>
<p>簡單來說就是一次送一大堆過去，一次收到有多少封包出問題，接著再一次送過去。</p>
<p><img alt="picture" src="../../_images/3_4-13.png" /></p>
</section>
<section id="go-back-n-gbn">
<h3>Go-Back-N (GBN)<a class="headerlink" href="#go-back-n-gbn" title="本標頭的永久連結"></a></h3>
<p>要使用GBN這個演算法的原因是因為記憶體是有限的，因此不會一次把整個檔案傳過去，而是有個會移動的window。</p>
<p><strong>Sender</strong>
<img alt="picture" src="../../_images/3_4-14.png" /></p>
<p>基本上就是依照記憶體的大小先給一個window，代表是隨時準備要傳出去了，那個windows裡面包含兩個部分，也就是sent but  not yet ack』ed (黃色)和usable but not yet sent（藍色），而 send_base 指向第一個黃色，nextseqnum指向第一個藍色，以下介紹兩個機制：</p>
<ol class="simple">
<li><p>cumulative ACK：假設目前的send_base指向9，但是receiver回傳11的ack，那這個演算法會將9 10 11都當作already ack』ed，並且send_base會指向12</p></li>
<li><p>timeout：假設目前的send_base指向9，nextseqnum指向20，如果發生timeout，那9~19都會一起再傳過去（timeout是以send_base為基準）。</p></li>
</ol>
<p><strong>Receiver</strong>
<img alt="picture" src="../../_images/3_4-15.png" /></p>
<ol class="simple">
<li><p>ACK-only：一次收到很多<strong>連續</strong>的封包，可以回報最高的那個就好(expected sequence number前一個)</p></li>
<li><p>ACK number = expected sequence number：期待下一個來的封包序號</p></li>
<li><p>注意，有可能封包來了，但是序號比你的expected number還要大(上圖紅色的地方)，那receiver該怎麼對這些數字比較大的封包呢？可以選擇丟掉或者留著都可以。</p></li>
</ol>
<p><strong>GBN 的FSM</strong></p>
<p>當作補充，看看就好</p>
<p><img alt="../../_images/3_4-gbn1.png" src="../../_images/3_4-gbn1.png" /></p>
<p><img alt="../../_images/3_4-gbn2.png" src="../../_images/3_4-gbn2.png" /></p>
</section>
<section id="selective-repeat-sr">
<h3>Selective Repeat (SR)<a class="headerlink" href="#selective-repeat-sr" title="本標頭的永久連結"></a></h3>
<p>sender直接回報給receiver每個封包的狀況，沒有使用cumulated的機制，因此每個封包的timer都是各自獨立的</p>
<p><img alt="picture" src="../../_images/3_4-16.png" /></p>
<p>總整理
<img alt="picture" src="../../_images/3_4-17.png" /></p>
<p><strong>A Dilemma</strong></p>
<p>假如編號編得不好，那可能會把錯誤的封包接在一起：例如總共有7個封包，分別編號1,2,3,4,1,2,3，假如receiver收到第二個封包後，收到了第七個封包，序號上來看是123沒問題，但實際上他跳過了很多封包</p>
<blockquote>
<div><p>這個錯誤是理論上的，因為現實情況數字非常的大，所以不太會有超級跳號的情況發生</p>
</div></blockquote>
<p><strong>小小比較</strong></p>
<blockquote>
<div><p>在網路環境比較好的情況下，GBN比較好</p>
</div></blockquote>
</section>
</section>
<section id="connection-oriented-transport-tcp">
<h2>3.5 Connection-Oriented Transport: TCP<a class="headerlink" href="#connection-oriented-transport-tcp" title="本標頭的永久連結"></a></h2>
<p>Overview</p>
<p><img alt="picture" src="../../_images/3_5-1.png" /></p>
<p>MSS: maximum segment size, 不同作業系統大小設定不一樣（單位是byte）</p>
<section id="tcp-segment-structure">
<h3>TCP Segment Structure<a class="headerlink" href="#tcp-segment-structure" title="本標頭的永久連結"></a></h3>
<p><img alt="pic" src="../../_images/3_5-2.png" /></p>
<p><strong>Head</strong>
word = 32 bits
C,E:網路不好用
U:urgent
A:ACK
P:Push
R:Reset
S:Syn
F:Fin</p>
<p><img alt="pic" src="../../_images/3_5-3.png" /></p>
<p><strong>TCP ACK</strong></p>
<ol class="simple">
<li><p>編號：對 segment 編號的方法其實是用 bit 的順序來編號，而 ack 的編號是下一個想要收到的 segment，當然，他是 cumulated 的。</p></li>
<li><p>tcp head裡面的東西改為A</p></li>
<li><p>TCP是雙方的，而兩邊各自的ack編號不一樣（因為兩個人傳的東西不一樣）</p></li>
</ol>
<p><strong>Timer</strong></p>
<p>而timer要怎麼設定呢？以RTT(round trip time)當作基準去訂定timeout時間</p>
<p>注意：不能直接訂平均，因為會把一半都當作timeout，因此平均要加上一個差值（參考下圖）</p>
<p><img alt="../../_images/3_5-timeout1.png" src="../../_images/3_5-timeout1.png" /></p>
<p><img alt="../../_images/3_5-timeout2.png" src="../../_images/3_5-timeout2.png" /></p>
<p><strong>TCP Sender(simplified)</strong></p>
<p>基本上跟GBN長得差不多</p>
<p>RTT一開始會由作業系統來決定，網路事件多一點之後就會動態決定那個 timeout 時間了</p>
<p><img alt="figure/3_5-4.png" src="figure/3_5-4.png" /></p>
<p>假如遇到duplicate的東西，那就不要理它</p>
<p><strong>TCP fast retransmit</strong></p>
<p>假如sender收到了連續的三個ACKs，那sender在收到timeout之前，我們就會把東西重送過去了（因為代表網路不好）</p>
</section>
<section id="flow-control">
<h3>Flow Control<a class="headerlink" href="#flow-control" title="本標頭的永久連結"></a></h3>
<p>因為只有receiver知道目前的網路環境、等等的，因此要把這個機制建立在receiver身上。</p>
<p>RcvBuffer: 他的大小一開始就被決定(4096 bite)。</p>
<p><img alt="../../_images/3_5-5.png" src="../../_images/3_5-5.png" /></p>
<p>主要要關注的事下方的free buffer space(只有receiver才知道)，在ACK中的某個小地方有個區域會告訴你free buffer space，叫sender節制一點（假如不節制，那傳過去的封包receiver負擔不了，只能丟掉）</p>
<p><strong>Connection Setup</strong></p>
<p>在真的要送東西之前，要先握手才會開始這段旅程</p>
<p>如果只有兩次握手呢？會有一大堆讓別人誤會的問題。</p>
<p>half open：右邊的 receiver 以為要建立，所以開了一個通道，但sender的東西太慢送來了，導致receiver會以為要再丟一次</p>
<p><img alt="../../_images/3_5-6.png" src="../../_images/3_5-6.png" /></p>
<p>TCP 3-way handshake</p>
<ol class="simple">
<li><p>SYNbit = 1, seq = z</p></li>
<li><p>SYNbitt = 1, Seq = y, ACKbit = 1, ACKnum = x + 1</p></li>
<li><p>ACKbit = 1, ACKnum = y+1.</p></li>
</ol>
<p>TCP: closing a connection</p>
<ol class="simple">
<li><p>準備關東西</p></li>
<li><p>要來弄FIN的東西</p></li>
<li><p>兩邊都沒東西要傳送了</p></li>
</ol>
<p>假設最後一個掉了怎麼辦？（因為是最後一個，得不到暗示），sender必須要等兩倍的segment lifte time，避免他不是真的最後一個。</p>
</section>
</section>
<section id="principles-of-congestion-control-control">
<h2>3.6 Principles of Congestion Control Control<a class="headerlink" href="#principles-of-congestion-control-control" title="本標頭的永久連結"></a></h2>
<p>sender 假如要自律發現網路不好，不要送太多，因為每個router都有自己的空間，假如空間不夠就會直接Loss掉，但router太忙了，他不會有空通知sender。</p>
<p>有四個速度，理論上會不一樣</p>
<p>TCP可以均分Router裡面的東西</p>
<ul class="simple">
<li><p>Scenario 1 <br>router裡面的容量無限</p></li>
<li><p>Scenario 2 <br>
Sender知道Router會不會滿出來（讓它不會有Loss）</p></li>
<li><p>Scenario 2.5 <br>
sender知道剛剛送的哪一個封包掉了（Router會滿出來）
重送有兩個狀況</p>
<ol class="simple">
<li><p>Timeout</p></li>
<li><p>Data 掉包
但目前只會出現第二種，因此那個速度只會差一點點</p></li>
</ol>
</li>
<li><p>Scenario 2.7 <br>
會有timeout的情況發生，而且會有兩種情況</p></li>
</ul>
<ol class="simple">
<li><p>真的掉了</p></li>
<li><p>沒掉，只是塞車</p></li>
</ol>
<p>從以上的情境我們可以知道，sender application傳送速率一定比 receiver application 的速率快。</p>
</section>
<section id="tcp-congestion-control">
<h2>3.7 TCP Congestion Control<a class="headerlink" href="#tcp-congestion-control" title="本標頭的永久連結"></a></h2>
<p>那具體來說sender到底該怎麼控制自己呢？主要是用收到的ack來猜測sender可不可以繼續增加，這種方式稱為AIMD( Additive Increase Multiplicative)</p>
<p><strong>術語分享</strong></p>
<ul class="simple">
<li><p>congestion window : TCP send 的中間的東西 (看起來跟GBN的window差不多）</p></li>
<li><p>cwnd：是congestion window 的大小</p></li>
<li><p>TCP rate: $\approx \dfrac{cwnd}{RTT}$</p></li>
<li><p>slow start:因為要確定receiver還有網路的狀況好不好，所以一開始會從1 MSS(maximum segment size)開始丟，接著丟的速度會指數成長。</p></li>
<li><p>ssthresh：不能一直指數成長，當突破這個值的時候會改成線性成長</p></li>
<li><p>congestion avoidance: 到達某個數字之後不用指數成長，用線性成長</p></li>
<li><p>Multiplicative decrease: 假如出現 packet loss 的情況，那將會降低速度來改善</p>
<ol class="simple">
<li><p>砍半速度(TCP Reno)，當 packet loss發生在triplicate duplicate的時候</p></li>
<li><p>降到 1 MSS (TCP Tahoe)，當packet loss 發生在timeout</p></li>
</ol>
</li>
</ul>
<p><strong>整個congestion的FSM</strong></p>
<p><img alt="../../_images/3_7-1.png" src="../../_images/3_7-1.png" /></p>
<p>[補充]</p>
<p>TCP CUBIC：被砍半之後變成一個左上角$\dfrac{1}{4}$ 圓形</p>
<section id="tcp-fairness">
<h3>TCP fairness<a class="headerlink" href="#tcp-fairness" title="本標頭的永久連結"></a></h3>
<p>(待補)</p>
</section>
</section>
<section id="evolution-of-transport-layer-functionality">
<h2>3.8 Evolution of Transport-Layer Functionality<a class="headerlink" href="#evolution-of-transport-layer-functionality" title="本標頭的永久連結"></a></h2>
<p>(老師沒講)</p>
</section>
<section id="summary">
<h2>3.9 Summary<a class="headerlink" href="#summary" title="本標頭的永久連結"></a></h2>
<p>（老師沒講）</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
        <a href="2.html" class="btn btn-neutral float-left" title="Chapter 2. Application Layer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
        <a href="4.html" class="btn btn-neutral float-right" title="Chapter 4 The Network Layer: Data Plane" accesskey="n" rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; 版權所有 2022, QSnake。</p>
  </div>

  利用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 构建，使用的 
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">主题</a>
    由 <a href="https://readthedocs.org">Read the Docs</a> 开发.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>